// Generated by CoffeeScript 1.6.3
(function() {
  var DB_URL, MongoClient, WHERE_COND, assert, mode, process, sleep;

  MongoClient = require('mongodb').MongoClient;

  sleep = require('sleep');

  assert = require('assert');

  DB_URL = 'mongodb://127.0.0.1:27017/tesis';

  WHERE_COND = "this.available_slices.length > 1 && this.status != 'reduced'";

  mode = function(array) {
    /*
    Devuelve la moda de un arreglo de cadenas.
    */

    var el, maxCount, maxEl, modeMap, _arr, _i, _len;
    if (array.length === 0) {
      return null;
    }
    _arr = [];
    array.forEach(function(item) {
      return _arr.push(JSON.stringify(item));
    });
    array = _arr;
    modeMap = {};
    maxEl = array[0];
    maxCount = 1;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      el = array[_i];
      if (modeMap[el] === void 0) {
        modeMap[el] = 1;
      } else {
        modeMap[el]++;
      }
      if (modeMap[el] > maxCount) {
        maxEl = el;
        maxCount = modeMap[el];
      }
    }
    return JSON.parse(maxEl);
  };

  process = function(task, coll) {
    /*
    Debe buscar la moda de los resultados de map para cada slice, el cual se lo
    considera correcto. Luego une los resultados de los slices y los agrega en
    `reduce_data`. Finalmente saca de `available_slices` los ya procesado. 
    
    No llama a reduce, pues primero es necesario procesar todos los maps.
    */

    var k, key, reduce_data, res, results, sid, vals, _data, _i, _len, _real_result, _reduce_data, _unavailable_sids, _update, _used_maps_results;
    results = task.map_results;
    _real_result = {};
    for (sid in results) {
      res = results[sid];
      if (res.length >= 5) {
        _real_result[sid] = mode(res);
      }
    }
    _unavailable_sids = (function() {
      var _i, _len, _ref, _results;
      _ref = Object.keys(_real_result);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sid = _ref[_i];
        _results.push(parseInt(sid));
      }
      return _results;
    })();
    _data = {};
    for (sid in _real_result) {
      reduce_data = _real_result[sid];
      for (key in reduce_data) {
        vals = reduce_data[key];
        if (!_data.hasOwnProperty(key)) {
          _data[key] = [];
        }
        _data[key].push.apply(_data[key], vals);
      }
    }
    _reduce_data = {};
    for (k in _data) {
      vals = _data[k];
      _reduce_data["reduce_data." + k] = {
        $each: vals
      };
    }
    _used_maps_results = {};
    for (_i = 0, _len = _unavailable_sids.length; _i < _len; _i++) {
      sid = _unavailable_sids[_i];
      _used_maps_results["map_results." + sid] = "";
    }
    _update = {
      $unset: _used_maps_results,
      $push: _reduce_data,
      $pull: {
        available_slices: {
          $in: _unavailable_sids
        }
      }
    };
    return coll.update({
      _id: task._id
    }, _update, function(err, count, status) {
      if (err !== null) {
        return console.error("ERROR: " + err);
      } else {
        if (count !== 1) {
          console.error("WARNING: It should update 1 record but " + count + " where          updated");
        }
        return console.log("INFO: " + status);
      }
    });
  };

  console.log("Conecting to DB...");

  MongoClient.connect(DB_URL, function(err, conn) {
    var coll;
    if (err !== null) {
      console.log(err);
      return;
    }
    console.log("Connected to DB");
    coll = conn.collection("workers");
    return coll.find({
      $where: WHERE_COND
    }).nextObject(function(err, task) {
      if (err !== null) {
        console.log("Error: ", err);
        return;
      }
      if (task === null) {
        return;
      }
      console.log("Procesando...", task._id);
      process(task, coll);
      console.log("Finishing proccessing task ", task._id);
      return conn.close();
    });
  });

}).call(this);
