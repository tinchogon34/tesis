// Generated by CoffeeScript 1.6.3
(function() {
  var MongoClient, ObjectID, WORKER_JS, allowCrossDomain, app, assert, bodyParser, compression, db, db_url, express, fs, getWork, get_slices, get_work_or_data, morgan, serveStatic, shuffle, trusted_hosts, _;

  express = require('express.io');

  bodyParser = require('body-parser');

  compression = require('compression');

  morgan = require('morgan');

  serveStatic = require('serve-static');

  assert = require('assert');

  fs = require('fs');

  MongoClient = require('mongodb').MongoClient;

  ObjectID = require('mongodb').ObjectID;

  _ = require("underscore");

  app = express();

  trusted_hosts = ['http://localhost:3000'];

  db_url = 'mongodb://127.0.0.1:27017/tesis';

  WORKER_JS = fs.readFileSync('worker.js', 'utf8');

  db = null;

  MongoClient.connect(db_url, function(err, connection) {
    assert.ifError(err);
    assert.ok(connection);
    return db = connection;
  });

  allowCrossDomain = function(req, res, next) {
    res.header('Access-Control-Allow-Origin', trusted_hosts);
    res.header('Access-Control-Allow-Methods', 'GET, POST');
    res.header('Access-Control-Allow-Headers', 'Content-Type');
    return next();
  };

  app.use(serveStatic(__dirname + '/public'));

  app.use(morgan('default'));

  app.use(bodyParser.json());

  app.use(bodyParser.urlencoded({
    extended: true
  }));

  app.use(compression());

  app.use(allowCrossDomain);

  shuffle = function(h) {
    var i, j, keys, randomKeyI, randomKeyJ, size, _i, _ref, _ref1;
    keys = Object.keys(h);
    size = keys.length;
    for (i = _i = 0, _ref = size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      randomKeyI = keys[i];
      j = Math.floor(Math.random() * size);
      randomKeyJ = keys[j];
      _ref1 = [h[randomKeyJ], h[randomKeyI]], h[randomKeyI] = _ref1[0], h[randomKeyJ] = _ref1[1];
    }
    return h;
  };

  get_slices = function(data, size) {
    var contador, hash, i, key, keysLength, value, _i, _ref;
    hash = {};
    keysLength = Object.keys(data).length;
    for (i = _i = 0, _ref = Math.floor(keysLength % size); 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      hash[i] = {
        "status": "created",
        "data": {}
      };
    }
    i = 0;
    contador = 0;
    for (key in data) {
      value = data[key];
      hash[i].data[key] = value;
      contador++;
      if (contador % size === 0) {
        i++;
      }
    }
    return shuffle(hash);
  };

  get_work_or_data = function(callback) {
    return db.collection('workers', function(err, collection) {
      if (err) {
        return callback({
          task_id: 0
        });
      }
      assert.ok(collection);
      return collection.find({
        "status": {
          $ne: "reduce_pending"
        }
      }).toArray(function(err, items) {
        var size, work;
        if (!items.length || err) {
          console.log("Workers empty");
          return callback({
            task_id: 0
          });
        }
        work = items[Math.floor(Math.random() * items.length)];
        size = Object.keys(work.slices).length;
        if (work.status !== 'reduce_pending' && work.received_count === size) {
          console.log("Entre al received");
          collection.update({
            _id: work._id
          }, {
            $set: {
              status: 'reduce_pending'
            }
          }, function(err, count) {
            if (err) {
              return callback({
                task_id: 0
              });
            }
            return assert.equal(1, count);
          });
          return get_work_or_data(callback);
        } else if (work.current_slice === size - 1) {
          return get_work_or_data(callback);
        }
        return collection.findAndModify({
          _id: work._id
        }, [], {
          $inc: {
            current_slice: 1
          }
        }, {
          "new": true
        }, function(err, work) {
          var arr, doc, key, value, _ref;
          if (err) {
            return callback({
              task_id: 0
            });
          }
          assert.ok(work);
          /* {"0": 1, "1": 1, "2": 2} => [["0",1],["1",1],["2",2]]*/

          /* PROC.JS COMPATIBILITY, REMOVE THIS!*/

          arr = [];
          _ref = work.slices[work.current_slice].data;
          for (key in _ref) {
            value = _ref[key];
            arr.push([key, value]);
          }
          doc = {
            task_id: work._id,
            slice_id: work.current_slice,
            data: arr,
            worker: work.worker_code + ";" + worker_js
          };
          return callback(doc);
        });
      });
    });
  };

  getWork = function(task_id, callback) {
    var coll;
    if (task_id == null) {
      task_id = null;
    }
    /*
    Busca en la DB un `task` con _id igual a `slice_id ` o si este es null,
    lo busca aleatoriamente. Luego llama a la funcion callback con task como 
    argumento
    */

    coll = db.collection('workers');
    if (task_id !== null) {
      coll.findOne({
        _id: new ObjectID(task_id)
      }, function(err, item) {
        if (err) {
          console.error(err);
          return;
        }
        return callback(item);
      });
      return;
    }
    return coll.find({
      "status": {
        $ne: "reduce_pending"
      }
    }).count(function(err, _n) {
      return coll.find({
        "status": {
          $ne: "reduce_pending"
        }
      }).limit(1).skip(_.random(_n - 1)).nextObject(function(err, item) {
        if (err) {
          console.error(err);
          return;
        }
        return callback(item);
      });
    });
  };

  /*
  Define HTTP method
  */


  app.get('/work', function(req, res) {
    return getWork(null, function(work) {
      return res.json({
        task_id: work._id,
        code: work.imap + ";" + WORKER_JS
      });
    });
  });

  app.get('/data', function(req, res) {
    var task_id;
    task_id = req.param("task_id");
    console.log("GET /data con task_id=" + task_id);
    if (!task_id) {
      res.status(400);
      return res.send("task_id required");
    }
    return getWork(task_id, function(work) {
      var _slice_id;
      _slice_id = _.sample(work.available_slices);
      return res.json({
        slice_id: _slice_id,
        data: work.slices[_slice_id]
      });
    });
  });

  app.post('/data', function(req, res) {
    /* 
    ( ͡° ͜ʖ ͡°)
    Postea resultados de los datos ya procesador. Devuelve mas datos para
    que el cliente siga *laburanding* Haters gonna hate ;).
    */

    var coll, slice_id, update;
    console.log("Posting to /data");
    if (void 0 === req.body.task_id || void 0 === req.body.slice_id || void 0 === req.body.result) {
      res.status(400);
      return res.send("get your shit together");
    }
    slice_id = req.param("slice_id");
    update = {};
    update["map_results." + slice_id] = req.param("result");
    coll = db.collection('workers');
    coll.update({
      _id: new ObjectID(req.param("task_id"))
    }, {
      $push: update
    }, function(err) {
      if (err !== null) {
        return console.error("Failed to update:", err);
      }
    });
    return getWork(req.param("task_id"), function(work) {
      var _slice_id;
      _slice_id = _.sample(work.available_slices);
      return res.json({
        slice_id: _slice_id,
        data: work.slices[_slice_id]
      });
    });
  });

  app.post('/form', function(req, res) {
    var data, doc, map, reduce;
    console.log(req.body);
    data = JSON.parse(req.body.data.replace(/'/g, "\""));
    map = req.body.map;
    reduce = req.body.reduce;
    doc = {
      data: data,
      worker_code: "investigador_map = " + map,
      reduce: reduce,
      map_results: {},
      reduce_results: {},
      slices: get_slices(data, 3),
      current_slice: -1,
      status: 'created',
      received_count: 0,
      send_count: 0
    };
    return db.collection('workers', function(err, collection) {
      assert.ifError(err);
      collection.insert(doc, {
        w: 1
      }, function(err, result) {
        assert.ifError(err);
        return assert.ok(result);
      });
      return res.send("Thx for submitting a job");
    });
  });

  app.post('/log', function(req, res) {
    console.log(req.body.message);
    return res.send(200);
  });

  console.log("listening to localhost:3000");

  app.listen('3000');

}).call(this);
