// Generated by CoffeeScript 1.6.1
(function() {
  var DbPath, MongoClient, ObjectID, WorkerJS, allowCrossDomain, app, assert, express, fs, get_slices, get_work_or_data, shuffle;

  express = require('express');

  assert = require('assert');

  fs = require('fs');

  MongoClient = require('mongodb').MongoClient;

  ObjectID = require('mongodb').ObjectID;

  app = express();

  DbPath = 'mongodb://127.0.0.1:27017/tesis';

  WorkerJS = fs.readFileSync('worker.js', 'utf8');

  allowCrossDomain = function(req, res, next) {
    res.header('Access-Control-Allow-Origin', ['http://127.0.0.1:3000']);
    res.header('Access-Control-Allow-Methods', 'GET, POST');
    res.header('Access-Control-Allow-Headers', 'Content-Type');
    return next();
  };

  app.use(express.compress());

  app.use(express["static"](__dirname + '/public'));

  app.use(express.logger());

  app.use(express.bodyParser());

  app.use(allowCrossDomain);

  shuffle = function(h) {
    var i, j, keys, randomKeyI, randomKeyJ, size, _i, _ref, _ref1;
    keys = Object.keys(h);
    size = keys.length;
    for (i = _i = 0, _ref = size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      randomKeyI = keys[i];
      j = Math.floor(Math.random() * size);
      randomKeyJ = keys[j];
      _ref1 = [h[randomKeyJ], h[randomKeyI]], h[randomKeyI] = _ref1[0], h[randomKeyJ] = _ref1[1];
    }
    return h;
  };

  get_slices = function(data, size) {
    var contador, hash, i, key, keysLength, value, _i, _ref;
    hash = {};
    keysLength = Object.keys(data).length;
    for (i = _i = 0, _ref = Math.floor(keysLength % size); 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      hash[i] = {
        "status": "created",
        "data": {}
      };
    }
    i = 0;
    contador = 0;
    for (key in data) {
      value = data[key];
      hash[i].data[key] = value;
      contador++;
      if (contador % size === 0) {
        i++;
      }
    }
    return shuffle(hash);
  };

  get_work_or_data = function(callback) {
    return MongoClient.connect(DbPath, function(err, db) {
      assert.equal(null, err);
      return db.collection('workers', function(err, collection) {
        assert.equal(null, err);
        return collection.find({
          "status": {
            $ne: "reduce_pending"
          }
        }).toArray(function(err, items) {
          var key, received_count, send_count, size, update, value, work, _ref;
          assert.equal(null, err);
          if (!items.length) {
            console.log("Workers empty");
            return callback({
              task_id: 0
            });
          }
          work = items[Math.floor(Math.random() * items.length)];
          received_count = 0;
          send_count = 0;
          _ref = work.slices;
          for (key in _ref) {
            value = _ref[key];
            if (value.status === 'received') {
              received_count++;
            } else if (value.status === 'send') {
              send_count++;
            }
          }
          size = Object.keys(work.slices).length;
          if (size === received_count) {
            console.log("Entre al received");
            collection.update({
              _id: work._id
            }, {
              $set: {
                status: 'reduce_pending'
              }
            }, function(err, count) {
              assert.equal(null, err);
              assert.equal(1, count);
              return get_work_or_data(callback);
            });
            return;
          } else if (send_count > 0) {
            console.log("Entre al send");
            collection.update({
              _id: work._id
            }, {
              $set: {
                status: 'receive_pending'
              }
            }, function(err, count) {
              assert.equal(null, err);
              assert.equal(1, count);
              return get_work_or_data(callback);
            });
            return;
          }
          update = {};
          update["slices." + (work.current_slice + 1) + ".status"] = "send";
          return collection.update({
            _id: work._id
          }, {
            $inc: {
              current_slice: 1
            },
            $set: update
          }, function(err, count) {
            var arr, doc, _ref1;
            assert.equal(null, err);
            assert.equal(1, count);
            arr = [];
            _ref1 = work.slices[work.current_slice + 1].data;
            for (key in _ref1) {
              value = _ref1[key];
              arr.push([key, value]);
            }
            doc = {
              task_id: work._id,
              slice_id: work.current_slice + 1,
              data: arr,
              worker: work.worker_code + ";" + WorkerJS
            };
            return callback(doc);
          });
        });
      });
    });
  };

  app.get('/work', function(req, res) {
    return get_work_or_data(function(work) {
      return res.json(work);
    });
  });

  app.post('/data', function(req, res) {
    var doc_id, result, slice_id, update;
    doc_id = req.body.task_id;
    slice_id = req.body.slice_id;
    result = req.body.result;
    update = {};
    update["map_results." + slice_id] = result;
    update["slices." + slice_id + ".status"] = "received";
    /*
    DO CHECKS # args are required
    */

    /*
    # TODO: esto tiene que ser un push, en vez de un set
    # Para almacenar varios resultados de un mismo slice, para luego elijir el
    # correcto. De esta manera prevenimos datos falsos.
    */

    return MongoClient.connect(DbPath, function(err, db) {
      assert.equal(null, err);
      return db.collection('workers', function(err, collection) {
        assert.equal(null, err);
        /*
        Debe esperar el resultado del update???
        */

        return collection.update({
          _id: new ObjectID(doc_id)
        }, {
          $set: update
        }, function(err, count) {
          assert.equal(null, err);
          assert.equal(1, count);
          return get_work_or_data(function(work) {
            return res.json(work);
          });
        });
      });
    });
  });

  app.post('/form', function(req, res) {
    var data, doc, map, reduce;
    data = JSON.parse(req.body.data.replace(/'/g, "\""));
    map = req.body.map;
    reduce = req.body.reduce;
    /*
    DO CHECKS
    */

    doc = {
      data: data,
      worker_code: "investigador_map = " + map,
      reduce: reduce,
      map_results: {},
      reduce_results: {},
      slices: get_slices(data, 3),
      current_slice: -1,
      status: 'created'
    };
    return MongoClient.connect(DbPath, function(err, db) {
      assert.equal(null, err);
      return db.collection('workers', function(err, collection) {
        assert.equal(null, err);
        return collection.insert(doc, {
          w: 1
        }, function(err, result) {
          assert.equal(null, err);
          return res.send("Thx for submitting a job");
        });
      });
    });
  });

  app.post('/log', function(req, res) {
    console.log(req.body.message);
    return res.send(200);
  });

  app.listen('3000');

}).call(this);
