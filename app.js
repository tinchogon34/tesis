// Generated by CoffeeScript 1.6.1
(function() {
  var DbPath, MongoClient, ObjectID, WorkerJS, allowCrossDomain, app, assert, db, express, fs, get_slices, get_work_or_data, shuffle;

  express = require('express');

  assert = require('assert');

  fs = require('fs');

  MongoClient = require('mongodb').MongoClient;

  ObjectID = require('mongodb').ObjectID;

  app = express();

  DbPath = 'mongodb://127.0.0.1:27017/tesis';

  db = null;

  MongoClient.connect(DbPath, function(err, connection) {
    assert.equal(null, err);
    return db = connection;
  });

  WorkerJS = fs.readFileSync('worker.js', 'utf8');

  allowCrossDomain = function(req, res, next) {
    res.header('Access-Control-Allow-Origin', ['http://127.0.0.1:3000']);
    res.header('Access-Control-Allow-Methods', 'GET, POST');
    res.header('Access-Control-Allow-Headers', 'Content-Type');
    return next();
  };

  app.use(express.compress());

  app.use(express["static"](__dirname + '/public'));

  app.use(express.logger());

  app.use(express.bodyParser());

  app.use(allowCrossDomain);

  shuffle = function(h) {
    var i, j, keys, randomKeyI, randomKeyJ, size, _i, _ref, _ref1;
    keys = Object.keys(h);
    size = keys.length;
    for (i = _i = 0, _ref = size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      randomKeyI = keys[i];
      j = Math.floor(Math.random() * size);
      randomKeyJ = keys[j];
      _ref1 = [h[randomKeyJ], h[randomKeyI]], h[randomKeyI] = _ref1[0], h[randomKeyJ] = _ref1[1];
    }
    return h;
  };

  get_slices = function(data, size) {
    var contador, hash, i, key, keysLength, value, _i, _ref;
    hash = {};
    keysLength = Object.keys(data).length;
    for (i = _i = 0, _ref = Math.floor(keysLength % size); 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      hash[i] = {
        "status": "created",
        "data": {}
      };
    }
    i = 0;
    contador = 0;
    for (key in data) {
      value = data[key];
      hash[i].data[key] = value;
      contador++;
      if (contador % size === 0) {
        i++;
      }
    }
    return shuffle(hash);
  };

  get_work_or_data = function(callback) {
    return db.collection('workers', function(err, collection) {
      assert.equal(null, err);
      return collection.find({
        "status": {
          $ne: "reduce_pending"
        }
      }).toArray(function(err, items) {
        var arr, doc, key, size, update, value, work, _ref;
        assert.equal(null, err);
        if (!items.length) {
          console.log("Workers empty");
          return callback({
            task_id: 0
          });
        }
        work = items[Math.floor(Math.random() * items.length)];
        size = Object.keys(work.slices).length;
        if (size === work.received_count) {
          console.log("Entre al received");
          collection.update({
            _id: work._id
          }, {
            $set: {
              status: 'reduce_pending'
            }
          }, function(err, count) {
            assert.equal(null, err);
            return assert.equal(1, count);
          });
          return get_work_or_data(callback);
        } else if (work.current_slice === size) {
          return get_work_or_data(callback);
        } else if (work.slices[work.current_slice].status === 'send') {
          console.log("Entre al send");
          /*
          collection.update {_id: work._id}, {$set: {status: 'receive_pending'}}, (err, count) ->
              assert.equal null, err
              assert.equal 1, count
          */

          return get_work_or_data(callback);
        }
        update = {};
        update["slices." + work.current_slice + ".status"] = "send";
        collection.update({
          _id: work._id
        }, {
          $inc: {
            current_slice: 1
          },
          $set: update
        }, function(err, count) {
          assert.equal(null, err);
          return assert.equal(1, count);
        });
        arr = [];
        _ref = work.slices[work.current_slice].data;
        for (key in _ref) {
          value = _ref[key];
          arr.push([key, value]);
        }
        doc = {
          task_id: work._id,
          slice_id: work.current_slice,
          data: arr,
          worker: work.worker_code + ";" + WorkerJS
        };
        return callback(doc);
      });
    });
  };

  app.get('/work', function(req, res) {
    return get_work_or_data(function(work) {
      return res.json(work);
    });
  });

  app.post('/data', function(req, res) {
    var doc_id, result, slice_id, update;
    doc_id = req.body.task_id;
    slice_id = req.body.slice_id;
    result = req.body.result;
    update = {};
    update["map_results." + slice_id] = result;
    update["slices." + slice_id + ".status"] = "received";
    /*
    DO CHECKS # args are required
    */

    /*
    # TODO: esto tiene que ser un push, en vez de un set
    # Para almacenar varios resultados de un mismo slice, para luego elijir el
    # correcto. De esta manera prevenimos datos falsos.
    */

    return db.collection('workers', function(err, collection) {
      assert.equal(null, err);
      /*
      Debe esperar el resultado del update???
      */

      collection.update({
        _id: new ObjectID(doc_id)
      }, {
        $inc: {
          received_count: 1
        },
        $set: update
      }, function(err, count) {
        assert.equal(null, err);
        assert.equal(1, count);
        return console.log("Updatee el received");
      });
      return get_work_or_data(function(work) {
        return res.json(work);
      });
    });
  });

  app.post('/form', function(req, res) {
    var data, doc, map, reduce;
    data = JSON.parse(req.body.data.replace(/'/g, "\""));
    map = req.body.map;
    reduce = req.body.reduce;
    /*
    DO CHECKS
    */

    doc = {
      data: data,
      worker_code: "investigador_map = " + map,
      reduce: reduce,
      map_results: {},
      reduce_results: {},
      slices: get_slices(data, 3),
      current_slice: 0,
      status: 'created',
      received_count: 0,
      send_count: 0
    };
    return db.collection('workers', function(err, collection) {
      assert.equal(null, err);
      collection.insert(doc, {
        w: 1
      }, function(err, result) {
        return assert.equal(null, err);
      });
      return res.send("Thx for submitting a job");
    });
  });

  app.post('/log', function(req, res) {
    console.log(req.body.message);
    return res.send(200);
  });

  app.listen('3000');

}).call(this);
